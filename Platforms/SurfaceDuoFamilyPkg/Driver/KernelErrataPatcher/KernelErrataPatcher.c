/** @file

  Patches NTOSKRNL to not cause a SError when reading/writing ACTLR_EL1
  Patches NTOSKRNL to not cause a SError when reading/writing AMCNTENSET0_EL0
  Patches NTOSKRNL to not cause a bugcheck when attempting to use
  PSCI_MEMPROTECT Due to an issue in QHEE

  Based on https://github.com/SamuelTulach/rainbow

  Copyright (c) 2021 Samuel Tulach
  Copyright (c) 2022-2023 DuoWoA authors

  SPDX-License-Identifier: MIT

**/
#include "KernelErrataPatcher.h"

#define SILENT 0

STATIC EFI_EXIT_BOOT_SERVICES EfiExitBootServices = NULL;

// Please see ./ShellCode/Reference/ShellCode.c for what this does
UINT8 OslArm64TransferToKernelShellCode[] = {
    0xEE, 0x03, 0x00, 0xAA, 0xC8, 0x0D, 0x41, 0xF8, 0x1F, 0x01, 0x0E, 0xEB,
    0xA0, 0x09, 0x00, 0x54, 0xA6, 0x1A, 0x87, 0x52, 0x06, 0x02, 0xA5, 0x72,
    0xA7, 0x1A, 0x83, 0x52, 0x07, 0x22, 0xA5, 0x72, 0xAA, 0x7A, 0x87, 0x52,
    0x4A, 0x1A, 0xB5, 0x72, 0xAC, 0x7A, 0x83, 0x52, 0x4C, 0x3A, 0xB5, 0x72,
    0x4D, 0x1A, 0x90, 0xD2, 0x0D, 0x60, 0xA0, 0xF2, 0x0D, 0x03, 0xC0, 0xF2,
    0x4D, 0xA0, 0xFA, 0xF2, 0x4F, 0x1A, 0x90, 0xD2, 0x0F, 0x40, 0xA0, 0xF2,
    0x4F, 0x1A, 0xD0, 0xF2, 0x0F, 0x60, 0xE0, 0xF2, 0x11, 0x03, 0x80, 0xD2,
    0x51, 0x00, 0xA8, 0xF2, 0x51, 0x1A, 0xD0, 0xF2, 0x11, 0x20, 0xE0, 0xF2,
    0xD2, 0xFA, 0x8B, 0x52, 0x72, 0x00, 0xB8, 0x72, 0x50, 0x1A, 0x90, 0xD2,
    0x10, 0x20, 0xA0, 0xF2, 0x50, 0x1A, 0xD0, 0xF2, 0x10, 0x40, 0xE0, 0xF2,
    0xAB, 0x7A, 0x80, 0x52, 0x0B, 0xE4, 0xA3, 0x72, 0x49, 0x1A, 0x90, 0x52,
    0x09, 0x00, 0xA1, 0x72, 0x26, 0x00, 0x00, 0x14, 0x49, 0x00, 0x00, 0xB9,
    0x42, 0x10, 0x00, 0x91, 0x5F, 0x00, 0x05, 0xEB, 0xE2, 0x03, 0x00, 0x54,
    0x43, 0x00, 0x40, 0xB9, 0x7F, 0x00, 0x06, 0x6B, 0x40, 0xFF, 0xFF, 0x54,
    0x7F, 0x00, 0x07, 0x6B, 0xE0, 0x01, 0x00, 0x54, 0x7F, 0x00, 0x0A, 0x6B,
    0xE0, 0x01, 0x00, 0x54, 0x7F, 0x00, 0x0C, 0x6B, 0xE0, 0x01, 0x00, 0x54,
    0x43, 0x00, 0x40, 0xF9, 0x7F, 0x00, 0x0D, 0xEB, 0xC0, 0x01, 0x00, 0x54,
    0x7F, 0x00, 0x0F, 0xEB, 0x01, 0xFE, 0xFF, 0x54, 0x43, 0x04, 0x40, 0xF9,
    0x7F, 0x00, 0x11, 0xEB, 0xA1, 0xFD, 0xFF, 0x54, 0x52, 0x40, 0x1E, 0xB8,
    0xEB, 0xFF, 0xFF, 0x17, 0x4B, 0x00, 0x00, 0xB9, 0xE9, 0xFF, 0xFF, 0x17,
    0x49, 0x00, 0x00, 0xB9, 0xE7, 0xFF, 0xFF, 0x17, 0x4B, 0x00, 0x00, 0xB9,
    0xE5, 0xFF, 0xFF, 0x17, 0x43, 0x04, 0x40, 0xF9, 0x7F, 0x00, 0x10, 0xEB,
    0x41, 0xFC, 0xFF, 0x54, 0x52, 0x00, 0x1E, 0xB8, 0xE0, 0xFF, 0xFF, 0x17,
    0x08, 0x01, 0x40, 0xF9, 0x1F, 0x01, 0x0E, 0xEB, 0x20, 0x01, 0x00, 0x54,
    0x02, 0x19, 0x40, 0xF9, 0x05, 0x41, 0x40, 0xB9, 0xA5, 0x00, 0x02, 0x8B,
    0x5F, 0x00, 0x05, 0xEB, 0x63, 0xFB, 0xFF, 0x54, 0xF8, 0xFF, 0xFF, 0x17,
    0x00, 0x00, 0x00, 0x14, 0x1F, 0x20, 0x03, 0xD5};

#if SILENT == 0

#define FirmwarePrint(x, ...)                                                  \
  AsciiPrint(x, __VA_ARGS__);                                                  \
  DEBUG((EFI_D_ERROR, x, __VA_ARGS__));

#else
#define FirmwarePrint(x, ...)
#endif

VOID KernelErrataPatcherApplyReadACTLREL1Patches(
    EFI_PHYSICAL_ADDRESS Base, UINTN Size)
{
  // Fix up #0 (28 10 38 D5 -> 08 00 80 D2) (ACTRL_EL1 Register Read)
  UINT8                FixedInstruction0[] = {0x08, 0x00, 0x80, 0xD2};
  EFI_PHYSICAL_ADDRESS IllegalInstruction0 =
      FindPattern(Base, Size, "28 10 38 D5");

  if (IllegalInstruction0 != 0) {
    FirmwarePrint("mrs x8, actlr_el1         -> 0x%p\n", IllegalInstruction0);

    CopyMemory(
        IllegalInstruction0, (EFI_PHYSICAL_ADDRESS)FixedInstruction0,
        sizeof(FixedInstruction0));
  }
}

EFI_STATUS
EFIAPI
KernelErrataPatcherExitBootServices(
    IN EFI_HANDLE ImageHandle, IN UINTN MapKey,
    IN EFI_PHYSICAL_ADDRESS fwpKernelSetupPhase1)
{
  // Might be called multiple times by winload in a loop failing few times
  gBS->ExitBootServices = EfiExitBootServices;

  FirmwarePrint(
      "OslFwpKernelSetupPhase1   -> (phys) 0x%p\n", fwpKernelSetupPhase1);

  EFI_PHYSICAL_ADDRESS winloadBase = LocateWinloadBase(fwpKernelSetupPhase1);
  FirmwarePrint("winloadBase   -> (phys) 0x%p\n", winloadBase);

  UINT64 OslMain = GetExport(winloadBase, "OslMain");
  FirmwarePrint("OslMain   -> (phys) 0x%p\n", OslMain);

  /*EFI_PHYSICAL_ADDRESS current = fwpKernelSetupPhase1;

  do {
    if (ARM64_BRANCH_LOCATION_INSTRUCTION(
            current, NT_OS_LOADER_ARM64_TRANSFER_TO_KERNEL_FUNCTION_OFFSET) ==
        *(UINT64 *)current) {
      FirmwarePrint(
          "Patching bl OsLoaderArm64TransferToKernel -> (phys) 0x%p\n",
          current);

      *(UINT64 *)current = ARM64_BRANCH_LOCATION_INSTRUCTION(
          current, NT_OS_LOADER_ARM64_TRANSFER_TO_KERNEL_FUNCTION_OFFSET -
                       sizeof(OslArm64TransferToKernelShellCode));

      FirmwarePrint(
          "Patching OsLoaderArm64TransferToKernel -> (phys) 0x%p\n", current);

      // Copy shell code right before the OsLoaderArm64TransferToKernelFunction
      CopyMemory(
          winloadBase + NT_OS_LOADER_ARM64_TRANSFER_TO_KERNEL_FUNCTION_OFFSET -
              sizeof(OslArm64TransferToKernelShellCode),
          (EFI_PHYSICAL_ADDRESS)OslArm64TransferToKernelShellCode,
          sizeof(OslArm64TransferToKernelShellCode));

      break;
    }

    current += ARM64_INSTRUCTION_LENGTH;
  } while (TRUE);

  // Fix up winload.efi
  // This fixes Boot Debugger
  FirmwarePrint(
      "Patching OsLoader         -> (phys) 0x%p (size) 0x%p\n",
      fwpKernelSetupPhase1, SCAN_MAX);

  KernelErrataPatcherApplyReadACTLREL1Patches(fwpKernelSetupPhase1, SCAN_MAX);*/

  FirmwarePrint(
      "OslFwpKernelSetupPhase1   <- (phys) 0x%p\n", fwpKernelSetupPhase1);

  // Call the original
  return gBS->ExitBootServices(ImageHandle, MapKey);
}

EFI_STATUS
EFIAPI
KernelErrataPatcherEntryPoint(
    IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)
{
  EfiExitBootServices   = gBS->ExitBootServices;
  gBS->ExitBootServices = ExitBootServicesWrapper;

  return EFI_SUCCESS;
}